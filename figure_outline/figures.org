#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+options: author:t broken-links:mark c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: A High-Throughput Computational Dataset of Halide Perovskite Alloys
#+date: \today
#+AUTHOR: Panayotis Manganaris\inst{1}
#+EMAIL: pmangana@purdue.edu
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 27.2 (Org mode 9.5)
#+startup: beamer
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [10pt, compress]
#+BEAMER_FRAME_LEVELS: 2
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
#+latex_header: \institute[Mannodi Group]{Purdue Materials Science and Engineering
#+latex_header: \inst{1} Mannodi Group
#+latex_header: \mode<beamer>{\usetheme{Warsaw}}
#+latex_header: \useoutertheme{miniframes}
#+begin_export latex
\expandafter\def\expandafter\insertshorttitle\expandafter{%
  \insertshorttitle\hfill
  \insertframenumber\,/\,\inserttotalframenumber}
#+end_export
* COMMENT Switch to scrymat environment:
#+begin_src emacs-lisp
  (conda-env-activate "scrymat")
#+end_src

#+RESULTS:
: Switched to conda environment: /opt/miniconda3/envs/scrymat/

* COMMENT import packages
#+begin_src jupyter-python :session "py" :kernel "scrymat" :exports "both" :results "none"
  import pandas as pd
  import sqlite3

  import matplotlib.pyplot as plt
  import matplotlib as mpl
  import mplcursors
  from matplotlib.ticker import NullFormatter
  #PCA
  from sklearn.decomposition import PCA
  from sklearn.preprocessing import StandardScaler
  #tSNE
  from sklearn import manifold, datasets
  #Utils                           
  from pathlib import Path
  import numpy as np
#+end_src

#+begin_src jupyter-python :session "py" :exports "both" :results "none"
  pd.options.plotting.backend="matplotlib"
  plt.style.use("dark_background")
#+end_src

* COMMENT interactive
#+begin_src jupyter-python :session "py" :exports "results" :results "raw drawer"
  #optionally use interactive qt canvas -- not set up nicely yet.
  %gui qt
  %matplotlib qt

  mplcursors.cursor(multiple = True).connect("add", lambda sel: sel.annotation.set_text(
      both_df.Formula_mannodi.values[sel.target.index]))
#+end_src

#+RESULTS:
: <function __main__.<lambda>(sel)>
* COMMENT inline
#+begin_src jupyter-python :session "py" :exports "results" :results "raw drawer"
  %gui inline
  %matplotlib qt
#+end_src

#+RESULTS:

* COMMENT load data
#+begin_src jupyter-python :session "py" :exports "both" :results "raw drawer"
  conn = sqlite3.connect("/home/panos/MannodiGroup/data/perovskites.db")
  sql_string = '''SELECT * 
                  FROM mannodi_agg'''
  mannodi_df = pd.read_sql(sql_string,
                           conn,
                           index_col='index')
  sql_string = '''SELECT * 
                  FROM almora_agg'''
  almora_df = pd.read_sql(sql_string,
                          conn,
                          #coerce_float=False,
                          index_col='index')
  conn.close()
#+end_src

#+RESULTS:

** prep almora for corroboration study
cutdown almora to definite comparables - exclude conjugate ratios described alloys
#+begin_src jupyter-python :session "py" :exports "results" :results "raw drawer"
  # filtering on the formula encoding cuts two entries not cut on the comp matri processing...
  #almora_df_sub = almora_df[almora_df.Formula.apply(lambda x: not bool(re.search(r'[x]', x)))]
  # almora currently contains non-numeric composition entries due to conjugate ratios in alloys
  # index all of these -- index all rows with any NaN
  idx = almora_df.iloc[:, 9:21].fillna(0).apply(pd.to_numeric, errors="coerce").isna().any(axis=1) 
  # cut down and ensure comp matrix column types are compatible
  almora_df = almora_df[~idx].apply(pd.to_numeric, errors="ignore")
#+end_src

#+RESULTS:

* COMMENT define biplot
#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  def biplot(components, PCs, transform_matrix, dim_labels=None, N_labels=[], ax=None, cbar_kw={}, cbarlabel="", **kwargs):
      """
      modify or create and return axis containing cross-section of pca space as
      scatter plot with projection of orignal dimensions onto the plane of major
      variance

      Parameters:
      ----------    
      components
      2-length list of integers from 0 to D-1. Selects 2 components to be scatter
      plotted against each other.
      PCs
      D-colummn DataFrame where each column is a principal component.
      transform_matrix
      DxD array of component weights summarizing the contribution of each dimension to
      each PC. Meant for use with PCA by sklearn.Decomposition.PCA.components_
      dim_labels
      D-length list of dimension labels corresponding the axes of the original
      data-space transformed in the PCA.
      N_labels
      Either:
      1. N-length pandas Series of unique labels to individually annotate each datapoint 
         Optionally, use cbar* args to control continuous coloration. String labels will be
         white.
      2. N-length list of nonunique labels to be annotate clusters of datapoints
         use with cbar* args to control descrete coloration
      3. None. Datapoints will be white and noninteractive


      Utility Args:
      -------------
      ax
      A `matplotlib.axes.Axes` instance on which the principal coordinates are scattered.
      If not provided, use current axes or create a new one.  Optional.
      cbar_kw
      A dictionary with arguments to `matplotlib.Figure.colorbar`.  Optional.
      cbarlabel
      The label for the colorbar.  Optional.
      ,**kwargs
      All other arguments are forwarded to `scatter`.

      transform_matrix is necssary for quantifying the contribution of each dimension
      to the principal components being plotted
      """
      if not ax:
          ax = plt.gca()
      #Number of dimensions to biplot
      n = transform_matrix.shape[0]
      #plot the plane of major variance
      xs = PCs.iloc[:,components[0]]
      ys = PCs.iloc[:,components[1]]
      scalex = 1.0/(xs.max() - xs.min())
      scaley = 1.0/(ys.max() - ys.min())
      N_labels = np.array(N_labels)
      unique = np.unique(N_labels)
      #wip:
      if (N_labels.size > unique.size) & (unique.size > 1): #color and annotate coords by discrete scale, disp scale
          #TODO if discrete scale consists of unique strings color discrete strings uniquely + label
          scatterplane = ax.scatter(xs * scalex, ys * scaley, c = N_labels, **kwargs)
          cbar = ax.figure.colorbar(scatterplane, ax=ax, **cbar_kw)
          cbar.ax.set_ylabel(cbarlabel, rotation=-90, va="bottom")
          # for key, value in np.arange(5):
          #     annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
          #                         bbox=dict(boxstyle="round", fc="w"),
          #                         arrowprops=dict(arrowstyle="->"))
          #     annot.set_visible(False)
      elif (N_labels.size == unique.size) & (unique.size > 1): #color and annotate coords by continuous scale, disp scale
          #TODO if continuous scale consists of unique strings label without color
          #if numbers, make and apply colorscale as well as label
          scatterplane = ax.scatter(xs * scalex, ys * scaley, c = N_labels, **kwargs)
          cbar = ax.figure.colorbar(scatterplane, ax=ax, **cbar_kw)
          cbar.ax.set_ylabel(cbarlabel, rotation=-90, va="bottom")
          annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                              bbox=dict(boxstyle="round", fc="w"),
                              arrowprops=dict(arrowstyle="->"))
          annot.set_visible(False)
      elif N_labels.size == 0: #quick view, no scale
          scatterplane = ax.scatter(xs * scalex, ys * scaley, c = "black", **kwargs)
      else:
          raise ValueError("N_labels badly argued. see biplot docstring")
      #plot and label projection of original dimensions on plane
      slice1 = transform_matrix[components[0]]
      slice2 = transform_matrix[components[1]]
      proj_slice_transposed = np.stack([slice1, slice2], axis=1)
      xs_weight = proj_slice_transposed[:,0]
      ys_weight = proj_slice_transposed[:,1]
      for i in range(n):
          ax.arrow(0, 0, xs_weight[i], ys_weight[i], color = 'r', alpha = 0.5)
          if dim_labels is None:
              ax.text(xs_weight[i] * 1.2, ys_weight[i] * 1.2, "Var"+str(i+1), color = 'g', ha = 'center', va = 'center')
          else:
              ax.text(xs_weight[i] * 1.2, ys_weight[i] * 1.2, dim_labels[i], color = 'g', ha = 'center', va = 'center')
      ax.set_xlabel("PC{}".format(components[0]))
      ax.set_ylabel("PC{}".format(components[1]))
      ax.grid()

      return ax
#+end_src

#+RESULTS:

* Methodology
:PROPERTIES:
:CUSTOM_ID: methodology
:END:
** DFT simulation premise                                          :B_frame:
:PROPERTIES:
:CUSTOM_ID: dft-details
:BEAMER_env: frame
:BEAMER_opt: allowframebreaks
:END:
*** Perovskite structure summary                                  :B_block:
:PROPERTIES:
:BEAMER_env: block
:COLUMNS:  0.5
:END:
#+DOWNLOADED: screenshot @ 2022-01-24 19:23:38
#+caption: label:fig:struct ABX_3 Cubic Perovskite Structure 
#+attr_org: :width 200
[[file:Methodology/2022-01-24_19-23-38_screenshot.png]]
*** Perovskite Chemical Domain                                    :B_block:
:PROPERTIES:
:BEAMER_env: block
:COLUMNS:  0.5
:END:
#+NAME: site_tbl
#+caption: label:tbl:chem ABX_3 Chemical Domain
| A-site | B-site | X-site |
|--------+--------+--------|
| MA     | Pb     | I      |
| FA     | Sn     | Br     |
| Cs     | Ge     | Cl     |
| Rb     | Ba     |        |
| K      | Sr     |        |
|        | Ca     |        |
|        | Be     |        |
|        | Mg     |        |
|        | Si     |        |
|        | V      |        |
|        | Cr     |        |
|        | Mn     |        |
|        | Fe     |        |
|        | Ni     |        |
|        | Zn     |        |
|        | Pd     |        |
|        | Cd     |        |
|        | Hg     |        |
** Composition Space Sampling                                      :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:BEAMER_opt: allowframebreaks
:END:
*** Sampling in DFT dataset                                       :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python :session "py" :exports "results" :results "raw drawer"
  %matplotlib inline
  fig = plt.figure(figsize=[12,6])
  gs = fig.add_gridspec(2,3)
  ax1 = fig.add_subplot(gs[0, 0])
  ax2 = fig.add_subplot(gs[1, 0])
  ax3 = fig.add_subplot(gs[0::, 1::])
  # counts constituent element's representation in fraction of total 550 compounds
  test_len = np.vectorize(len)
  cols = mannodi_df.columns.values[test_len(mannodi_df.columns.values) == 2]
  compound_rep = mannodi_df[cols][mannodi_df[cols] > 0].notna().sum(axis=0)
  #ax3.pie(compound_rep, labels = )
  ax3.set_title("Constituent Element Representation Fractions")

  patches, texts = ax3.pie(compound_rep)
  labels = ['{0} - {1:1.2f}'.format(i,j) for i,j in zip(compound_rep.index.values, compound_rep)]

  sort_legend = True
  if sort_legend:
      patches, labels, dummy =  zip(*sorted(zip(patches, labels, compound_rep.index.values),
                                            key=lambda x: x[2],
                                            reverse=True))

  plt.legend(patches, labels, loc='center right', bbox_to_anchor=(0.1, 0.5),
             fontsize=8)
  #second count constituent element's net weight fraction of total 550 x 5 net unit weights
  #sum the composition matrix columns
  mixing_rep = pd.get_dummies(mannodi_df.Mixing).sum(axis=0)
  ax2.pie(mixing_rep, labels = mixing_rep.index.values)
  ax2.set_title("Representation of Alloy Constructs")

  sumcomp=mannodi_df.iloc[:, 2:16].sum(axis=0)
  ax1.pie(sumcomp, labels = sumcomp.index.values)
  ax1.set_title("constituent weight fractions out of whole")
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/8f1d4f1aa030bd0ee679d35e9f028fd0a4997cc5.png]]
**** COMMENT notes
The computational dataset consists of 550 compositions of cubic
perovskites. 536 of which are purely based on only different
combinations of 14 standard constituent elements elaborated in figure
ref:fig:struct_chem. The perovskites arising from these constituents
are the focus of this analysis. The composition space is evenly
represented by each of the 14 constituent elements as illustrated in
figure ref:fig:dft_rep (a). Evidently, the computational setting
affords much more even coverage of the chemical domain compared to
physical experiments.

Furthermore, both pure site and alloyed site compounds are
explored. Mostly cite specific alloying is tested, the detailed
divisions are listed in table ref:tbl:mixing. Figure ref:fig:dft_rep
(b) summarizes the representation of each alloy construct. The alloy
space is certainly much larger than the pure space. However this
dataset is not yet large enough to fully explore it.
*** Sampling in experimental dataset                              :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python :session "py" :exports "results" :results "raw drawer"
  fig = plt.figure(figsize=[12,6])
  gs = fig.add_gridspec(2,3)
  ax1 = fig.add_subplot(gs[0, 0])
  ax2 = fig.add_subplot(gs[1, 0])
  ax3 = fig.add_subplot(gs[0::, 1::])
  # counts constituent element's representation in fraction of total 550 compounds
  test_len = np.vectorize(len)
  cols = almora_df.columns.values[test_len(almora_df.columns.values) == 2]
  compound_rep = almora_df[cols][almora_df[cols] > 0].notna().sum(axis=0)
  #ax3.pie(compound_rep, labels = )
  ax3.set_title("Constituent Element Representation Fractions")

  patches, texts = ax3.pie(compound_rep)
  labels = ['{0} - {1:1.2f}'.format(i,j) for i,j in zip(compound_rep.index.values, compound_rep)]

  sort_legend = True
  if sort_legend:
      patches, labels, dummy =  zip(*sorted(zip(patches, labels, compound_rep.index.values),
                                            key=lambda x: x[2],
                                            reverse=True))

  plt.legend(patches, labels, loc='center right', bbox_to_anchor=(0.1, 0.5),
             fontsize=8)
  #second count constituent element's net weight fraction of total 550 x 5 net unit weights
  #sum the composition matrix columns
  mixing_rep = pd.get_dummies(almora_df.Mixing).sum(axis=0)
  ax2.pie(mixing_rep, labels = mixing_rep.index.values)
  ax2.set_title("Representation of Alloy Constructs")

  sumcomp=almora_df[cols].sum(axis=0)
  ax1.pie(sumcomp, labels = sumcomp.index.values)
  ax1.set_title("constituent weight fractions out of whole")
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/dcb62144b4024f99ad012a5dac7e0bdac84b5968.png]]

*** TODO COMMENT flowchart of workflow                            :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
** Topology of Computational Composition Space                     :B_frame:
:PROPERTIES:
:CUSTOM_ID: exp-vs-comp
:BEAMER_env: frame
:BEAMER_opt: allowframebreaks
:END:
*** computation samples Variance shares                           :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python :session "py" :exports none :results raw drawer
  test_len = np.vectorize(len)
  mannodi_comp_cols = mannodi_df.columns.values[test_len(mannodi_df.columns.values) == 2]
  pdf_compu_comp = pd.DataFrame(StandardScaler().fit_transform(mannodi_df[mannodi_comp_cols].fillna(0)),
                                index = mannodi_df[mannodi_comp_cols].index, columns = mannodi_df[mannodi_comp_cols].columns)
  comp_label = pdf_compu_comp.columns.values
#+end_src

#+RESULTS:

#+begin_src jupyter-python :session "py" :exports none :results raw drawer
  pcaxis = PCA(n_components = min(pdf_compu_comp.shape), svd_solver = 'full')
#+end_src

#+RESULTS:

#+begin_src jupyter-python :session "py" :exports none :results raw drawer
  PCs = ['pc_%i' % i for i in range(pcaxis.n_components)]
  pdf_pcmodel = pd.DataFrame(pcaxis.fit_transform(pdf_compu_comp), index=pdf_compu_comp.index, columns=PCs)
  #pdf_pcmodel_plus = pd.concat([pdf_pcmodel, pdf_pse[["Formula"]]], axis=1)
  #scdf_pcmodel_plus
#+end_src

#+RESULTS:

#+begin_src jupyter-python :session "py" :exports results :results raw drawer
  #Obtain PC axes and name them nicely
  scree = pcaxis.explained_variance_ratio_
  screefig = plt.figure(figsize = [15,5])
  plt.plot(PCs, scree, '*')
  plt.title('Proportion of Variance explained by Principal Components')
  plt.ylabel('Fraction of Variance')
  plt.show()
#+end_src
*** PCA projection of Mannodi composition                         :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python :session "py" :exports results :results raw drawer
  #Call the function. Use only the 2 PCs at a time.
  fig, ax1 = plt.subplots(1,1, figsize=(6,6))

  plane = biplot([0,1], pdf_pcmodel, pcaxis.components_, dim_labels=comp_label, ax=ax1,)
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
#+attr_org: :width 552
[[file:./.ob-jupyter/5902b5ff1d6349e8f36ce1aabaede144c396a274.png]]
:END:

** Topology of Experimental Composition Space                      :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
*** Experimental samples Variance shares                          :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python :session "py" :exports none :results raw drawer
  almora_comp_cols = almora_df.columns.values[test_len(almora_df.columns.values) == 2]
  pdf_exp_comp = pd.DataFrame(StandardScaler().fit_transform(almora_df[almora_comp_cols].fillna(0)),
                                index = almora_df[almora_comp_cols].index, columns = almora_df[almora_comp_cols].columns)
  al_comp_label = pdf_exp_comp.columns.values
#+end_src

#+RESULTS:

here, use the mannodi composition space to compare coverages of the topology
#+begin_src jupyter-python :session "py" :exports none :results raw drawer
  pcaxis = PCA(n_components = min(pdf_compu_comp[almora_comp_cols].shape), svd_solver = 'full')
#+end_src

#+RESULTS:

#+begin_src jupyter-python :session "py" :exports none :results raw drawer
  PCs = ['pc_%i' % i for i in range(pcaxis.n_components)]
  pdf_pcmodel = pd.DataFrame(pcaxis.fit_transform(pdf_exp_comp), index=pdf_exp_comp.index, columns=PCs)
  #pdf_pcmodel_plus = pd.concat([pdf_pcmodel, pdf_pse[["Formula"]]], axis=1)
  #scdf_pcmodel_plus
#+end_src

#+RESULTS:

#+begin_src jupyter-python :session "py" :exports results :results raw drawer
  #Obtain PC axes and name them nicely
  scree = pcaxis.explained_variance_ratio_
  screefig = plt.figure(figsize = [15,5])
  plt.plot(PCs, scree, '*')
  plt.title('Proportion of Variance explained by Principal Components')
  plt.ylabel('Fraction of Variance')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/7fa258949ef6f94fc65290b3f795348b6257ca80.png]]

*** projection of Experimental compositions into Mannodi space    :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python :session "py" :exports results :results raw drawer
  #Call the function. Use only the 2 PCs at a time.
  fig, ax1 = plt.subplots(1,1, figsize=(6,6))

  plane = biplot([0,1], pdf_pcmodel, pcaxis.components_, dim_labels=al_comp_label, ax=ax1)
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
#+attr_org: :width 563
[[file:./.ob-jupyter/716a588caef9af7978ee203e8bc1d6a9b8ca3274.png]]
:END:
* Results
:PROPERTIES:
:CUSTOM_ID: results
:END:
Here, a selection of experimentally obtained Perovskite band gaps
aggregated for twelve different compounds by Almora et.al.
[[cite:&almora-2020-devic-perfor]] are compared to computed band gaps

Almora computed the Power Conversion Efficiency of a variety of solar
cell devices from the short circuit current density, open circuit
voltage, and "Fill Factor"

#+begin_src jupyter-python :session "py" :exports "none" :results "raw drawer"
  # identify composition matrix labels
  almora_comp_cols = almora_df.columns.values[test_len(almora_df.columns.values) == 2]
  # create corroborative table by unioning all indicies on the joint composion matrix + indicate source
  union_df = pd.merge(mannodi_df, almora_df, on=list(almora_comp_cols), how='outer', indicator=True, suffixes=("_mannodi", "_almora"))
  both_df = union_df[union_df._merge=="both"]
#+end_src

#+RESULTS:
** Computational vs Experimental                                   :B_frame:
:PROPERTIES:
:CUSTOM_ID: man_alm_bg
:BEAMER_env: frame
:END:
*** band gaps                                                     :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
parity comparisons indicate PBE underestimates bandgaps and HSE
overestimates bandgaps systematically

#+begin_src jupyter-python :session "py" :exports "results" :results "raw drawer" :file ./.ob-jupyter/BGcorrob.png
  def axsquare(ax):
      """improve comparative presentation of two data series with pairity"""
      minx, maxx = ax.get_xlim()
      miny, maxy = ax.get_ylim()
      axmax = max([maxx, maxy])
      axmin = min([minx, miny])
      ax.set_xlim(axmin, axmax)
      ax.set_ylim(axmin, axmax)

  fig, (ax1, ax2) = plt.subplots(1,2, figsize=[15,6])

  cor = both_df.dropna(subset=list(almora_comp_cols), how="all")

  groups = cor.groupby(cor.Formula_almora)
  for name, group in groups:
      ax1.scatter(group.EMP_bg_eV, group.PBE_bg_eV, label = name)
      ax2.scatter(group.EMP_bg_eV, group.HSE_bg_eV, label = name)      
  axsquare(ax1)
  axsquare(ax2)
  ax1.axline((0,0), slope=1, ls='-')
  ax2.axline((0,0), slope=1, ls='-')  
  ax1.set_title("Comparing PBE simulation with Experimental Bandgaps")
  ax2.set_title("Comparing HSE simulation with Experimental Bandgaps")
  ax1.set_xlabel("Almora Bandgap [eV]")
  ax2.set_xlabel("Almora Bandgap [eV]")  
  ax1.set_ylabel("PBE Bandgap [eV]")
  ax2.set_ylabel("HSE Bandgap [eV]")  
  lgd = ax2.legend()
  lgd.loc = "lower right"
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/BGcorrob.png]]

*** table                                                         :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python :session "py" :exports "both" :results "raw drawer"
  both_df[["Formula_mannodi", "EMP_bg_eV", "PBE_bg_eV", "HSE_bg_eV"]]
#+end_src

#+RESULTS:
|     | Formula_mannodi | EMP_bg_eV | PBE_bg_eV | HSE_bg_eV |
|-----+-----------------+-----------+-----------+-----------|
|   5 | MASnI3          |      1.31 |     0.879 |    2.5741 |
|   6 | MASnI3          |       1.4 |     0.879 |    2.5741 |
|   7 | MAPbI3          |      1.61 |     1.852 |    2.6353 |
|   8 | MAPbI3          |      1.62 |     1.852 |    2.6353 |
|   9 | MAPbI3          |       1.6 |     1.852 |    2.6353 |
|  10 | MAPbI3          |      1.65 |     1.852 |    2.6353 |
|  11 | MAPbI3          |      1.53 |     1.852 |    2.6353 |
|  12 | MAPbI3          |       1.6 |     1.852 |    2.6353 |
|  13 | MAPbI3          |      1.65 |     1.852 |    2.6353 |
|  14 | MAPbI3          |       1.6 |     1.852 |    2.6353 |
|  15 | MAPbI3          |      1.55 |     1.852 |    2.6353 |
|  16 | MAPbI3          |      1.59 |     1.852 |    2.6353 |
|  17 | MAPbI3          |       1.6 |     1.852 |    2.6353 |
|  18 | MAPbI3          |      1.61 |     1.852 |    2.6353 |
|  19 | MAPbI3          |      1.53 |     1.852 |    2.6353 |
|  20 | MAPbI3          |      1.55 |     1.852 |    2.6353 |
|  21 | MAPbI3          |      1.63 |     1.852 |    2.6353 |
|  22 | MAPbI3          |      1.62 |     1.852 |    2.6353 |
|  23 | MAPbI3          |      1.55 |     1.852 |    2.6353 |
|  24 | MAPbI3          |      1.63 |     1.852 |    2.6353 |
|  25 | MAPbI3          |       1.6 |     1.852 |    2.6353 |
|  26 | MAPbI3          |      1.55 |     1.852 |    2.6353 |
|  27 | MAPbI3          |      1.63 |     1.852 |    2.6353 |
|  28 | MAPbI3          |      1.63 |     1.852 |    2.6353 |
|  29 | MAPbBr3         |      2.32 |     1.974 |    3.4084 |
|  30 | MAPbCl3         |      3.03 |     2.526 |    3.8377 |
|  35 | CsSnBr3         |      2.35 |     0.634 |    1.3894 |
|  36 | CsSnI3          |      1.31 |     0.483 |    1.1556 |
|  38 | CsPbBr3         |      2.31 |     1.774 |    2.5758 |
|  39 | CsPbBr3         |      2.33 |     1.774 |    2.5758 |
|  40 | CsPbBr3         |      2.34 |     1.774 |    2.5758 |
|  41 | CsPbBr3         |      2.35 |     1.774 |    2.5758 |
|  42 | CsPbBr3         |      2.38 |     1.774 |    2.5758 |
|  43 | CsPbI3          |      1.74 |     1.482 |    2.1633 |
|  49 | FASnI3          |      1.44 |     1.054 |    2.8648 |
|  50 | FASnI3          |      1.44 |     1.054 |    2.8648 |
|  52 | FAPbBr3         |      2.27 |     2.112 |    3.5353 |
|  53 | FAPbI3          |      1.53 |     1.942 |    2.8146 |
|  54 | FAPbI3          |      1.54 |     1.942 |    2.8146 |
| 130 | KSrI3           |      1.65 |      3.17 |    4.1325 |
| 131 | KCaI3           |      1.65 |     3.258 |    4.2203 |
| 132 | K-Rb-Cs-BX3184  |      1.65 |      0.57 |       nan |
| 133 | K-Rb-Cs-BX3222  |      1.65 |     0.958 |       nan |
| 134 | K-Rb-Cs-BX314   |      1.65 |     1.466 |       nan |
| 135 | K-Rb-Cs-BX3584  |      1.65 |     3.856 |       nan |
| 136 | K-Rb-Cs-BX3379  |      1.65 |     3.218 |       nan |
| 137 | K-Rb-Cs-BX3398  |      1.65 |     3.327 |       nan |
| 138 | K-Rb-Cs-BX3159  |      1.65 |     0.411 |       nan |
| 139 | K-Rb-Cs-BX317   |      1.65 |     1.458 |       nan |
| 140 | K-Rb-Cs-BX3285  |      1.65 |     2.433 |       nan |
| 141 | K-Rb-Cs-BX3302  |      1.65 |     1.907 |       nan |
| 534 | MAPbI1.5Br1.5   |      1.87 |     1.893 |    3.2688 |
| 535 | MAPbI1.5Br1.5   |       1.9 |     1.893 |    3.2688 |
** Trends in Computational Data                                    :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:BEAMER_opt: allowframebreaks
:END:
*** COMMENT HSE PCA op
#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  hse_outs = ['HSE_LC', 'HSE_bg_eV', 'HSE_dbg_eV', 'HSE_FormE_eV', 'HSE_DecoE_eV']
  pdf_hse = pd.DataFrame(StandardScaler().fit_transform(mannodi_df[hse_outs].dropna()),
                         index = mannodi_df[hse_outs].dropna().index, columns = mannodi_df[hse_outs].columns)
  hse_label = pdf_hse.columns.values
#+end_src

#+RESULTS:

#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  pcaxis = PCA(n_components = min(pdf_hse.shape), svd_solver = 'full')
#+end_src

#+RESULTS:

#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  PCs = ['pc_%i' % i for i in range(pcaxis.n_components)]
  pdf_pcmodel = pd.DataFrame(pcaxis.fit_transform(pdf_hse), index=pdf_hse.index, columns=PCs)
  #pdf_pcmodel_plus = pd.concat([pdf_pcmodel, pdf_pse[["Formula"]]], axis=1)
  #scdf_pcmodel_plus
#+end_src

#+RESULTS:

#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  #Obtain PC axes and name them nicely
  scree = pcaxis.explained_variance_ratio_
  screefig = plt.figure(figsize = [15,5])
  plt.plot(PCs, scree, '*')
  plt.title('Proportion of Variance explained by Principal Components')
  plt.ylabel('Fraction of Variance')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/4b96d0c88c935d26b7d14992d57a5e51c6cb1d0a.png]]
*** HSE results                                                   :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  #Call the function. Use only the 2 PCs at a time.
  fig, (ax1, ax2) = plt.subplots(1,2, figsize=(16,6))

  plane_LC = biplot([0,1], pdf_pcmodel, pcaxis.components_, dim_labels=hse_label, ax=ax1, N_labels=mannodi_df["HSE_LC"].dropna())
  plane_bg = biplot([0,1], pdf_pcmodel, pcaxis.components_, dim_labels=hse_label, ax=ax2, N_labels=mannodi_df["HSE_bg_eV"].dropna())
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/7d2d75ceef4bb57614094fcb0a2af8b9d15918ca.png]]
*** COMMENT PBE PCA op
#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  pbe_outs = ['PBE_LC', 'PBE_bg_eV', 'PBE_dbg_eV', 'PBE_FormE_eV', 'PBE_DecoE_eV', 'dielc', 'PV_FOM', 'SLME_5um', 'SLME_100um']
  pdf_pbe = pd.DataFrame(StandardScaler().fit_transform(mannodi_df[pbe_outs].dropna()),
                         index = mannodi_df[pbe_outs].dropna().index, columns = mannodi_df[pbe_outs].columns)
  pbe_label = pdf_pbe.columns.values
#+end_src

#+RESULTS:

#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  pcaxis = PCA(n_components = min(pdf_pbe.shape), svd_solver = 'full')
#+end_src

#+RESULTS:

#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  PCs = ['pc_%i' % i for i in range(pcaxis.n_components)]
  pdf_pcmodel = pd.DataFrame(pcaxis.fit_transform(pdf_pbe), index=pdf_pbe.index, columns=PCs)
  #pdf_pcmodel_plus = pd.concat([pdf_pcmodel, pdf_pse[["Formula"]]], axis=1)
  #scdf_pcmodel_plus
#+end_src

#+RESULTS:

#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  #Obtain PC axes and name them nicely
  scree = pcaxis.explained_variance_ratio_
  screefig = plt.figure(figsize = [15,5])
  plt.plot(PCs, scree, '*')
  plt.title('Proportion of Variance explained by Principal Components')
  plt.ylabel('Fraction of Variance')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/98a7051a3f0c7b24a88ead40adf5d03bd97e794f.png]]
*** PBE results                                                   :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  #Call the function. Use only the 2 PCs at a time.
  fig, (ax1, ax2) = plt.subplots(1,2, figsize=(16,6))

  plane_LC = biplot([0,1], pdf_pcmodel, pcaxis.components_, dim_labels=pbe_label, ax=ax1, N_labels=mannodi_df["SLME_5um"].dropna())
  plane_bg = biplot([0,1], pdf_pcmodel, pcaxis.components_, dim_labels=pbe_label, ax=ax2, N_labels=mannodi_df["PBE_bg_eV"].dropna())
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/31e788491b6aa6d149463dbbcfe5ba03a59088da.png]]
* MDS

* ISOMAP

* UMAP

* TODO TSNE projections
** mannodi chemical space
recover information loss plot
#+begin_src jupyter-python :session "py" :exports both :results raw drawer
  comp_cols = ['K', 'Rb', 'Cs', 'MA', 'FA', 'Ca', 'Sr', 'Ba', 'Ge', 'Sn', 'Pb', 'Cl', 'Br', 'I']
  perplexities = [5, 30, 50, 100]
  fig, subplots = plt.subplots(1, len(perplexities)+1, figsize=(15, 3))

  ax = subplots[0]
  comp_matrix = mannodi_df.loc[:, comp_cols].dropna().to_numpy().T

  ax.scatter(comp_matrix[0],comp_matrix[1])
  ax.set_xlabel("# K in unit cell")
  ax.set_ylabel("# Rb in unit cell")

  for i, perplexity in enumerate(perplexities):
    ax = subplots[i + 1]
    tsne = manifold.TSNE(n_components=2, init="pca", learning_rate=200,
                         random_state=1, perplexity=perplexity)
    Warped = tsne.fit_transform(StandardScaler().fit_transform(X=comp_matrix.T))
    ax.set_title("Perplexity={p}".format(p = perplexity))
    ax.set() # show the color bar and set the aspect ratio square
    ax.scatter(Warped.T[0], Warped.T[1]) #colorscale should not warped when physical
    ax.xaxis.set_major_formatter(NullFormatter())
    ax.yaxis.set_major_formatter(NullFormatter())
    ax.axis('tight')
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/ed0e9ec5f8890bd5b8af2a8a8e6c521ec66e430d.png]]

** properties space
** chemical space warped by addendum
 #+begin_src jupyter-python :session "py" :exports both :results raw drawer 
   perplexities = [5, 30, 50, 100]
   fig, subplots = plt.subplots(1, len(perplexities)+1, figsize=(15, 3))
   
   ax = subplots[0]
   Xmix_array = mannodi_df[[*cols,"PBE_DecoE_eV"]].dropna().to_numpy().T
   
   ax.scatter(Xmix_array[11],Xmix_array[12])
   ax.set_xlabel("# Cl in unit cell")
   ax.set_ylabel("# Br in unit cell")
   
   Xmix_array.shape
   
   for i, perplexity in enumerate(perplexities):
     ax = subplots[i + 1]
   
     tsne = manifold.TSNE(n_components=2, init='random',
                          random_state=0, perplexity=perplexity)
     Warped = tsne.fit_transform(StandardScaler().fit_transform(X=Xmix_array.T)) #just really be
                                                    #careful about the
                                                    #orientation of the
                                                    #training data. Dimensions should be
                                                    #columns. Observations should be rows.
   
     #scatter takes X and Y conveniently when rows are transpposed to
     #ax0, so it can be confusing in the set up.
   
     #Look into plotting this directly from the datafram.
   
     ax.set_title("Perplexity={p}".format(p = perplexity))
     ax.set() # show the color bar and set the aspect ratio square
     ax.scatter(Warped.T[0], Warped.T[1], c=Xmix_array[-1]) #colorscale should not warped when physical
     ax.xaxis.set_major_formatter(NullFormatter())
     ax.yaxis.set_major_formatter(NullFormatter())
     ax.axis('tight')
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/bf7994e6efd2ee2e90307d070a79e92cbf31a6f3.png]]

* figure ideas
3. show frequency of investigation over time (as in paper)
4. show change in band gap with multidimensional ratio shift
* reference
** citations                                                       :B_frame:
:PROPERTIES:
:BEAMER_env: frame
:END:
bibliographystyle:plain
bibliography:~/org/bibliotex/bibliotex.bib
