#+TITLE: Comparing Perovskite Datasets
#+AUTHOR: Panayotis Manganaris
#+EMAIL: pmangana@purdue.edu
#+PROPERTY: header-args :session mrg2 :kernel mrg :async yes :pandoc org
* COMMENT DEV dependencies
todo: when fit/transform methods are piped to dataframes the columns should be automatically serialized and de-serialized
#+begin_src jupyter-python :exports results :results raw drawer
  %load_ext autoreload
  %autoreload 2
#+end_src

#+RESULTS:
:results:
:end:
  
#+begin_src jupyter-python :exports results :results raw drawer
  import sys, os
  sys.path.append(os.path.expanduser("~/src/cmcl"))
  sys.path.append(os.path.expanduser("~/src/yogi")) # for frame transformers...
  sys.path.append(os.path.expanduser("~/src/spyglass"))
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :exports results :results raw drawer
  # featurization
  import cmcl
  import yogi
  #from yogi.data.frame import *
  from cmcl import Categories
  # visualization convenience
  from spyglass.model_imaging import parityplot
  from spyglass.spyglass import biplot
  import mplcursors
#+end_src

#+RESULTS:
:results:
: [INFO] 2022-06-27 13:47:21 - Note: NumExpr detected 12 cores but "NUMEXPR_MAX_THREADS" not set, so enforcing safe limit of 8.
: [INFO] 2022-06-27 13:47:21 - NumExpr defaulting to 8 threads.
:end:

#+begin_src jupyter-python :exports results :results raw drawer
  from sklearnex import patch_sklearn
  patch_sklearn()
#+end_src

#+RESULTS:
:results:
: Intel(R) Extension for Scikit-learn* enabled (https://github.com/intel/scikit-learn-intelex)
:end:
  
#+begin_src jupyter-python :exports results :results raw drawer
  # data tools
  import traceback
  import re
  import sqlite3
  import pandas as pd
  import numpy as np
  from functools import partial
  # feature engineering
  from sklearn.impute import SimpleImputer
  from sklearn.preprocessing import OrdinalEncoder, Normalizer, StandardScaler
  #transformers
  from sklearn.decomposition import PCA, TruncatedSVD, KernelPCA
  from sklearn.manifold import TSNE
  #visualization
  from sklearn import set_config
  import matplotlib.pyplot as plt
  import seaborn as sns
  # ignore all FutureWarnings -- handling coming in a future version of yogi
  from warnings import simplefilter
  simplefilter(action='ignore', category=FutureWarning)
#+end_src

#+RESULTS:
:results:
:end:

* load data
** load from database
#+begin_src jupyter-python :exports results :results raw drawer
  mannodi_pbe_q = """SELECT *
                     FROM mannodi_pbe"""
  almora_q = """SELECT *
                FROM almora"""
  mannodi_hse_q = """SELECT *
                     FROM mannodi_hse"""
  sqlref = """SELECT *
              FROM mannodi_ref_elprop"""
  sqlother = """SELECT *
                FROM mannodi_ref_emp"""
  zone_q = """SELECT *
              FROM zone_prop"""
  with sqlite3.connect(os.path.expanduser("~/src/cmcl/cmcl/db/perovskites.db")) as conn:
      mannodi_pbe = pd.read_sql(mannodi_pbe_q, conn, index_col="index")
      mannodi_hse = pd.read_sql(mannodi_hse_q, conn, index_col="index")
      almora = pd.read_sql(almora_q, conn, index_col='index')
      zone = pd.read_sql(zone_q, conn, index_col='index')
      lookup = pd.read_sql(sqlref, conn, index_col='index')
#+end_src

#+RESULTS:
:results:
:end:

** load LCs
#+begin_src jupyter-python :exports results :results raw drawer
  briones = pd.read_csv('./briones_LC.csv')
  jiang = pd.read_csv('./jiang_LC.csv')
  hybrids = pd.read_csv('./hybrids.csv')
  lattice = pd.concat([briones, jiang, hybrids], axis=0)
#+end_src

#+RESULTS:
:results:
:end:

* Clean Data
going forward we just assume that almora consists primarily of cubic phase crystals
** subset based on deviation from cubicity
#+begin_src jupyter-python :exports results :results raw drawer
  exclude = ["Rb0.375Cs0.625GeBr3", "RbGeBr1.125Cl1.875", "K0.75Cs0.25GeI3", "K8Sn8I9Cl15"]
  mannodi_pbe = mannodi_pbe[~mannodi_pbe.Formula.isin(exclude)]
  mannodi_hse = mannodi_hse[~mannodi_hse.Formula.isin(exclude)]
  almora = almora[~almora.Formula.isin(exclude)]
  lattice = lattice[~lattice.Formula.isin(exclude)]
#+end_src

#+RESULTS:
:results:
:end:
** adjust formula strings for comparability
#+begin_src jupyter-python :exports results :results raw drawer
  lattice.Formula = lattice.Formula.str.replace("NH4","AM")
#+end_src

#+RESULTS:
:results:
:end:

** Comp vs Experimental directivity
- trim and aggregate band gaps in datasets with band gaps
- trim and aggregate LC in datasets with LCs
#+begin_src jupyter-python :exports results :results raw drawer
  #use index to transfer categorical variables through aggregation
  almora = almora.groupby('Formula').agg({'bg_eV':'median', #make an auto dict...
                                          'efficiency':'median',
                                          'citation':'first'}).reset_index()
  almora = almora.reindex(index=almora['bg_eV'].dropna().index)

  mannodi_pbe = mannodi_pbe.groupby('Formula').agg({'bg_eV':'median',
                                                    'efficiency':'median',
                                                    'LC_A':'median',
                                                    'sim_cell':'first',
                                                    'bgType':'first'}).reset_index()
  mannodi_pbe = mannodi_pbe.reindex(index=mannodi_pbe['bg_eV'].dropna().index)

  mannodi_hse = mannodi_hse.groupby('Formula').agg({'bg_eV':'median',
                                                    'LC_A':'median',
                                                    'sim_cell':'first',
                                                    'bgType':'first'}).reset_index()
  mannodi_hse = mannodi_hse.reindex(index=mannodi_hse['bg_eV'].dropna().index)

  lattice = lattice.groupby('Formula').agg({'LC_A':'median'}).reset_index()
  lattice = lattice.reindex(index=lattice['LC_A'].dropna().index)
#+end_src

#+RESULTS:
:results:
:end:

* Compute Composition Vectors
#+begin_src jupyter-python :exports results :results raw drawer
  pc = mannodi_pbe.ft.comp().iloc[:, :14:]
  hc = mannodi_hse.ft.comp().iloc[:, :14:]
  ac = almora.ft.comp()
  lc = lattice.ft.comp()
#+end_src

#+RESULTS:
:results:
:end:

** subset index
lattice records are ready
*** cut down pbe by comp total
#+begin_src jupyter-python :exports results :results raw drawer
  size = mannodi_pbe.sim_cell.isin(["2x2x2"])
  pc = pc.collect.abx()
  g = pc.groupby(level=0, axis=1).sum()
  vB, vX, vA, = g.A.isin([1, 8]), g.B.isin([1, 8]), g.X.isin([3, 24])
  #subset indexes
  focus = size*vB*vA*vX
  pc = pc[focus]
  mannodi_pbe = mannodi_pbe[focus]
#+end_src

#+RESULTS:
:results:
:end:

*** cut down hse by comp total
#+begin_src jupyter-python :exports results :results raw drawer
  size = mannodi_hse.sim_cell.isin(["2x2x2"])
  hc = hc.collect.abx()
  g = hc.groupby(level=0, axis=1).sum()
  vB, vX, vA, = g.A.isin([1, 8]), g.B.isin([1, 8]), g.X.isin([3, 24])
  #subset indexes
  focus = size*vB*vA*vX
  hc = hc[focus]
  mannodi_hse = mannodi_hse[focus]
#+end_src

#+RESULTS:
:results:
:end:

*** cut down almora by comp total
#+begin_src jupyter-python :exports results :results raw drawer
  ac = ac.applymap(pd.to_numeric, errors='coerce')
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :exports results :results raw drawer
  ac = ac.collect.abx()
  g = ac.groupby(level=0, axis=1).sum()
  vB, vX, vA, = g.A.isin([1, 8]), g.B.isin([1, 8]), g.X.isin([3, 24])
  #subset indexes
  focus = vB*vA*vX
  ac = ac[focus]
  almora = almora[focus]
#+end_src

#+RESULTS:
:results:
:end:
** generate mix categories
*** pbe mix
#+begin_src jupyter-python :exports results :results raw drawer
  mixlog = pc.groupby(level=0, axis=1).count()
  mix = mixlog.pipe(Categories.logif, condition=lambda x: x>1, default="pure", catstring="and")
  mannodi_pbe = mannodi_pbe.assign(mix=mix)
#+end_src

#+RESULTS:
:results:
:end:

*** hse mix
#+begin_src jupyter-python :exports results :results raw drawer
  mixlog = hc.groupby(level=0, axis=1).count()
  mix = mixlog.pipe(Categories.logif, condition=lambda x: x>1, default="pure", catstring="and")
  mannodi_hse = mannodi_hse.assign(mix=mix)
#+end_src

#+RESULTS:
:results:
:end:

*** almora mix
#+begin_src jupyter-python :exports results :results raw drawer
  mixlog = ac.groupby(level=0, axis=1).count()
  mix = mixlog.pipe(Categories.logif, condition=lambda x: x>1, default="pure", catstring="and")
  almora = almora.assign(mix=mix)
#+end_src

#+RESULTS:
:results:
:end:

*** lattice mix
#+begin_src jupyter-python :exports results :results raw drawer
  mixlog = lc.groupby(level=0, axis=1).count()
  mix = mixlog.pipe(Categories.logif, condition=lambda x: x>1, default="pure", catstring="and")
  lattice = lattice.assign(mix=mix)
#+end_src

#+RESULTS:
:results:
:end:

** generate Organics Categories
*** pbe org
#+begin_src jupyter-python :exports results :results raw drawer
  organics = mannodi_pbe.ft.comp().collect.org()
  orglog = organics.groupby(level=0, axis=1).count()
  org = orglog.pipe(Categories.logif, condition=lambda x: x>=1, default="error", catstring="_&_")
  mannodi_pbe = mannodi_pbe.assign(org=org)
#+end_src

#+RESULTS:
:results:
:end:

*** hse mix
#+begin_src jupyter-python :exports results :results raw drawer
  organics = mannodi_hse.ft.comp().collect.org()
  orglog = organics.groupby(level=0, axis=1).count()
  org = orglog.pipe(Categories.logif, condition=lambda x: x>=1, default="error", catstring="_&_")
  mannodi_hse = mannodi_hse.assign(org=org)
#+end_src

#+RESULTS:
:results:
:end:

*** almora mix
#+begin_src jupyter-python :exports results :results raw drawer
  organics = almora.ft.comp().collect.org()
  orglog = organics.groupby(level=0, axis=1).count()
  org = orglog.pipe(Categories.logif, condition=lambda x: x>=1, default="error", catstring="_&_")
  almora = almora.assign(org=org)
#+end_src

#+RESULTS:
:results:
:end:

*** lattice mix
#+begin_src jupyter-python :exports results :results raw drawer
  organics = lattice.ft.comp().collect.org()
  orglog = organics.groupby(level=0, axis=1).count()
  org = orglog.pipe(Categories.logif, condition=lambda x: x>=1, default="error", catstring="_&_")
  lattice = lattice.assign(org=org)
#+end_src

#+RESULTS:
:results:
:end:

* build comparisons tables
** scatter composition vectors in preparation for join ops
#+begin_src jupyter-python :exports results :results raw drawer
  pc.columns = pc.columns.droplevel('site')
  hc.columns = hc.columns.droplevel('site')
  ac.columns = ac.columns.droplevel('site')
#+end_src

#+RESULTS:
:results:
:end:

** concatenate tables and perform join ops
#+begin_src jupyter-python :exports results :results raw drawer
  def robust_compare(compare1, on1, compare2, on2, how='inner', suf1='x', suf2='y'):
      """from comparisons, should add to yogi
      be careful, make sure that the difference between on1 and on2 is not too excessive
      """
      df1 = pd.concat([compare1, on1], axis=1)
      df2 = pd.concat([compare2, on2], axis=1)
      intersection = [v for v in on1.columns.to_list() if v in on2.columns.to_list()]
      difference = [v for v in on1.columns.to_list() + on2.columns.to_list() if v not in intersection]
      join = pd.merge(df1, df2, on=intersection,
                      how=how, suffixes=("_"+suf1, "_"+suf2))
      if difference:
          return join[join[difference].isna().agg('prod', axis=1).apply(bool)]
      else:
          return join

  hse_v_pbe = robust_compare(mannodi_hse, hc, mannodi_pbe.drop(['mix', 'org'], axis=1), pc, suf1='hse', suf2='pbe')
  ebg_v_pbe = robust_compare(almora, ac, mannodi_pbe.drop(['mix', 'org'], axis=1), pc, suf1='exp', suf2='pbe')
  ebg_v_hse = robust_compare(almora, ac, mannodi_hse.drop(['mix', 'org'], axis=1), hc, suf1='exp', suf2='hse')
  elc_v_pbe = robust_compare(lattice, lc, mannodi_pbe.drop(['mix', 'org'], axis=1), pc, suf1='exp', suf2='pbe')
  elc_v_hse = robust_compare(lattice, lc, mannodi_hse.drop(['mix', 'org'], axis=1), hc, suf1='exp', suf2='hse')
#+end_src

#+RESULTS:
:results:
:end:

* Computed Targets vs Experimental Targets
** PBE v HSE band gaps
#+begin_src jupyter-python :exports both :results raw drawer
  plt.style.use('default')
  %matplotlib qt
#+end_src

#+RESULTS:
:results:
:end:
  
#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=hse_v_pbe,
                    x='bg_eV_pbe', y='bg_eV_hse', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    p.savefig('./pbe_v_hse_bg.png', transparent=True)
#+end_src

** PBE v HSE Lattice Constants
#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=hse_v_pbe,
                    x='LC_A_pbe', y='LC_A_hse', hue='org', style='mix',
                    height=6, aspect=1.3)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    p.savefig('./pbe_v_hse_LC.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

** PBE v experimental band gaps/efficiencies
Here, a selection of experimentally obtained Perovskite bandgaps
aggregated for different compounds by Almora et.al.
[[cite:&almora-2020-devic-perfor]] are compared to computed band gaps.

Almora measured the band gap and computed the Power Conversion
Efficiency of a variety of solar cell devices from published
measurements of the short circuit current density, open circuit
voltage, and "Fill Factor."

parity comparisons indicate PBE underestimates bandgaps and HSE
overestimates bandgaps systematically

#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=ebg_v_pbe,
                    x='bg_eV_exp', y='bg_eV_pbe', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    p.savefig('./pbe_v_almora_bg.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=ebg_v_pbe,
                    x='efficiency_exp', y='efficiency_pbe', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    p.savefig('./pbe_v_almora_eff.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

** hse v experimental band gaps
#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=ebg_v_hse,
                    x='bg_eV_exp', y='bg_eV_hse', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    p.savefig('./hse_v_almora_bg.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

** PBE v experimental LC
#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=elc_v_pbe,
                    x='LC_A_exp', y='LC_A_pbe', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    mplcursors.cursor(multiple=True).connect(
        "add", lambda sel: sel.annotation.set_text(
          elc_v_pbe["Formula_exp"].iloc[sel.index]
          )
      )
    #p.savefig('./pbe_v_exp_LC.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

** HSE v experimental LC
#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=elc_v_hse,
                    x='LC_A_exp', y='LC_A_hse', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    mplcursors.cursor(multiple=True).connect(
        "add", lambda sel: sel.annotation.set_text(
          elc_v_hse["Formula_exp"].iloc[sel.index]
          )
      )
    #p.savefig('./hse_v_exp_LC.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

* again, but improving figure layouts
* Mannodi vs Materials Zone
Over 40,000 experimentally measured bandgaps and efficiency
measurements collected by [[cite:&jacobsson-2021-open-acces]].
#+begin_src jupyter-python :export none :results raw drawer
  zc = zone.rename(columns={'Compound':'Formula'}).ft.comp()
#+end_src

#+RESULTS:
:results:
:end:

* MultiPhase Comparisons
#+begin_src jupyter-python :export none :results raw drawer
  sample_set = ["MAGeI3",
                "MAGeBr3",
                "FASnBr3",
                "CsPbI3",
                "CsSnI3",
                "FASnI3",
                "MAPbBr3",
                "MAPbI3",
                "FASnCl3",
                "CsSnCl3",
                "CsGeCl3",
                "MAPbCl3",
                "MASnBr3",
                "CsPbCl3",
                "MASnI3",
                "FAPbI3",
                "MASnCl3",
                "MAPb0.75Sn0.25I3",
                "CsGeBr3",
                "CsPbBr3",
                "CsSnBr3",
                "CsGeI3",
                "FAGeBr3",
                "FAGeCl3",
                "FAPbBr3",
                "FAPbCl3",
                "MAGeCl3",
                "FAGeI3",]
  sample = pd.DataFrame(sample_set, columns=["Formula"])
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :export none :results raw drawer
  agg = robust_compare(sample, sample.ft.comp(),
                       lattice, lc,
                       how='left',
                       suf1="samp", suf2="pbe")[['Formula_samp', 'Formula_pbe', 'bg_eV']]
  agg.set_index('Formula_samp').reindex(index=sample.Formula).reset_index()
#+end_src

#+begin_src jupyter-python :export none :results raw drawer
  zone_agg = robust_compare(sample, sample.ft.comp(),
                            zone, zc,
                            how='left',
                            suf1="samp", suf2="zone")[['Formula_samp', 'bg_eV']].fillna(0).groupby('Formula_samp', as_index=False).agg('median')
  zone_agg.bg_eV = zone_agg.bg_eV.apply(pd.to_numeric, errors='coerce')

  zone_rep = robust_compare(sample, sample.ft.comp(),
                            zone, zc,
                            how='left',
                            suf1="samp", suf2="zone")[['Formula_samp', 'bg_eV']].groupby('Formula_samp', as_index=False).count()
#+end_src

#+RESULTS:
:results:
# [goto error]
: [0;31m---------------------------------------------------------------------------[0m
: [0;31mNameError[0m                                 Traceback (most recent call last)
: [0;32m/tmp/ipykernel_13620/3082699280.py[0m in [0;36m<module>[0;34m[0m
: [1;32m      1[0m zone_agg = robust_compare(sample, sample.ft.comp(),
: [0;32m----> 2[0;31m                           [0mzone[0m[0;34m,[0m [0mzc[0m[0;34m,[0m[0;34m[0m[0;34m[0m[0m
: [0m[1;32m      3[0m                           [0mhow[0m[0;34m=[0m[0;34m'left'[0m[0;34m,[0m[0;34m[0m[0;34m[0m[0m
: [1;32m      4[0m                           suf1="samp", suf2="zone")[['Formula_samp', 'bg_eV']].fillna(0).groupby('Formula_samp', as_index=False).agg('median')
: [1;32m      5[0m [0mzone_agg[0m[0;34m.[0m[0mbg_eV[0m [0;34m=[0m [0mzone_agg[0m[0;34m.[0m[0mbg_eV[0m[0;34m.[0m[0mapply[0m[0;34m([0m[0mpd[0m[0;34m.[0m[0mto_numeric[0m[0;34m,[0m [0merrors[0m[0;34m=[0m[0;34m'coerce'[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
: 
: [0;31mNameError[0m: name 'zc' is not defined
:end:

#+begin_src jupyter-python :export none :results raw drawer
  zone_rep.set_index('Formula_samp').loc[sample.Formula, :].reset_index().bg_eV
  zone_rep.set_index('Formula_samp').reindex(sample.Formula).reset_index().bg_eV
#+end_src

[[cite:&jiang-2006-predic-lattic]]

[[cite:&briones-2021-accel-lattic]]

[[cite:&chen-2015-under-spotl]]
