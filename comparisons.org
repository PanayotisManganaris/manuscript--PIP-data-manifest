#+TITLE: Comparing Perovskite Datasets
#+AUTHOR: Panayotis Manganaris
#+EMAIL: pmangana@purdue.edu
#+PROPERTY: header-args :session mrg :kernel mrg :async yes :pandoc org
* load data
#+INCLUDE: /home/panos/MannodiGroup/publications/Perovskites_dataset_manifest/load_full_domain.org
as of yet disorganized experimental data to supplement our dataset
#+begin_src jupyter-python :exports results :results raw drawer
  briones = pd.read_csv('./briones_LC.csv')
  jiang = pd.read_csv('./jiang_LC.csv')
  hybrids = pd.read_csv('./hybrids.csv')
  lattice = pd.concat([briones, jiang, hybrids], axis=0)
#+end_src

#+RESULTS:
:results:
:end:

* Clean Data
** subset based on deviation from cubicity
#+begin_src jupyter-python :exports results :results raw drawer
  lattice = lattice[~lattice.Formula.isin(exclude)]
#+end_src

#+RESULTS:
:results:
:end:
** adjust formula strings for comparability
#+begin_src jupyter-python :exports results :results raw drawer
  lattice.Formula = lattice.Formula.str.replace("NH4","AM")
#+end_src

#+RESULTS:
:results:
:end:

** Comp vs Experimental directivity
- trim and aggregate LC
#+begin_src jupyter-python :exports results :results raw drawer
  lattice = lattice.groupby('Formula').agg({'LC_A':'median'}).reset_index()
  lattice = lattice.reindex(index=lattice['LC_A'].dropna().index)
#+end_src

#+RESULTS:
:results:
:end:

* Compute Composition Vectors
#+begin_src jupyter-python :exports results :results raw drawer
  lc = lattice.ft.comp()
#+end_src

#+RESULTS:
:results:
:end:

** generate Organics Categories
*** lattice mix
#+begin_src jupyter-python :exports results :results raw drawer
  organics = lattice.ft.comp().collect.org()
  orglog = organics.groupby(level=0, axis=1).count()
  org = orglog.pipe(Categories.logif, condition=lambda x: x>=1, default="error", catstring="_&_")
  lattice = lattice.assign(org=org)
#+end_src

#+RESULTS:
:results:
:end:

* TODO build comparisons tables
#+begin_src jupyter-python :exports results :results raw drawer
  hse_v_pbe = robust_compare(mannodi_hse, hc, mannodi_pbe.drop(['mix', 'org'], axis=1), pc, suf1='hse', suf2='pbe')
  ebg_v_pbe = robust_compare(almora, ac, mannodi_pbe.drop(['mix', 'org'], axis=1), pc, suf1='exp', suf2='pbe')
  ebg_v_hse = robust_compare(almora, ac, mannodi_hse.drop(['mix', 'org'], axis=1), hc, suf1='exp', suf2='hse')
  elc_v_pbe = robust_compare(lattice, lc, mannodi_pbe.drop(['mix', 'org'], axis=1), pc, suf1='exp', suf2='pbe')
  elc_v_hse = robust_compare(lattice, lc, mannodi_hse.drop(['mix', 'org'], axis=1), hc, suf1='exp', suf2='hse')
#+end_src

#+RESULTS:
:results:
:end:

* Computed Targets vs Experimental Targets
** PBE v HSE band gaps
#+begin_src jupyter-python :exports both :results raw drawer
  plt.style.use('default')
  %matplotlib qt
#+end_src

#+RESULTS:
:results:
:end:
  
#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=hse_v_pbe,
                    x='bg_eV_pbe', y='bg_eV_hse', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    p.savefig('./pbe_v_hse_bg.png', transparent=True)
#+end_src

** PBE v HSE Lattice Constants
#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=hse_v_pbe,
                    x='LC_A_pbe', y='LC_A_hse', hue='org', style='mix',
                    height=6, aspect=1.3)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    p.savefig('./pbe_v_hse_LC.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

** PBE v experimental band gaps/efficiencies
Here, a selection of experimentally obtained Perovskite bandgaps
aggregated for different compounds by Almora et.al.
[[cite:&almora-2020-devic-perfor]] are compared to computed band gaps.

Almora measured the band gap and computed the Power Conversion
Efficiency of a variety of solar cell devices from published
measurements of the short circuit current density, open circuit
voltage, and "Fill Factor."

parity comparisons indicate PBE underestimates bandgaps and HSE
overestimates bandgaps systematically

#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=ebg_v_pbe,
                    x='bg_eV_exp', y='bg_eV_pbe', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    p.savefig('./pbe_v_almora_bg.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=ebg_v_pbe,
                    x='efficiency_exp', y='efficiency_pbe', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    p.savefig('./pbe_v_almora_eff.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

** hse v experimental band gaps
#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=ebg_v_hse,
                    x='bg_eV_exp', y='bg_eV_hse', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    p.savefig('./hse_v_almora_bg.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

** PBE v experimental LC
#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=elc_v_pbe,
                    x='LC_A_exp', y='LC_A_pbe', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    mplcursors.cursor(multiple=True).connect(
        "add", lambda sel: sel.annotation.set_text(
          elc_v_pbe["Formula_exp"].iloc[sel.index]
          )
      )
    #p.savefig('./pbe_v_exp_LC.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

** HSE v experimental LC
#+begin_src jupyter-python :exports both :results raw drawer
  with sns.plotting_context('poster'):
    p = sns.relplot(data=elc_v_hse,
                    x='LC_A_exp', y='LC_A_hse', hue='org', style='mix',
                    height=6, aspect=1.2)
    xlims = p.figure.axes[0].get_xlim()
    ylims = p.figure.axes[0].get_ylim()
    plt.axline((min(xlims+ylims), min(xlims+ylims)),
               (max(xlims+ylims), max(xlims+ylims)),
               c='k')
    mplcursors.cursor(multiple=True).connect(
        "add", lambda sel: sel.annotation.set_text(
          elc_v_hse["Formula_exp"].iloc[sel.index]
          )
      )
    #p.savefig('./hse_v_exp_LC.png', transparent=True)
#+end_src

#+RESULTS:
:results:
:end:

* again, but improving figure layouts
* Mannodi vs Materials Zone
Over 40,000 experimentally measured bandgaps and efficiency
measurements collected by [[cite:&jacobsson-2021-open-acces]].
#+begin_src jupyter-python :export none :results raw drawer
  zc = zone.rename(columns={'Compound':'Formula'}).ft.comp()
#+end_src

#+RESULTS:
:results:
:end:

* MultiPhase Comparisons
#+begin_src jupyter-python :export none :results raw drawer
  sample_set = ["MAGeI3",
                "MAGeBr3",
                "FASnBr3",
                "CsPbI3",
                "CsSnI3",
                "FASnI3",
                "MAPbBr3",
                "MAPbI3",
                "FASnCl3",
                "CsSnCl3",
                "CsGeCl3",
                "MAPbCl3",
                "MASnBr3",
                "CsPbCl3",
                "MASnI3",
                "FAPbI3",
                "MASnCl3",
                "MAPb0.75Sn0.25I3",
                "CsGeBr3",
                "CsPbBr3",
                "CsSnBr3",
                "CsGeI3",
                "FAGeBr3",
                "FAGeCl3",
                "FAPbBr3",
                "FAPbCl3",
                "MAGeCl3",
                "FAGeI3",]
  sample = pd.DataFrame(sample_set, columns=["Formula"])
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :export none :results raw drawer
  agg = robust_compare(sample, sample.ft.comp(),
                       lattice, lc,
                       how='left',
                       suf1="samp", suf2="pbe")[['Formula_samp', 'Formula_pbe', 'bg_eV']]
  agg.set_index('Formula_samp').reindex(index=sample.Formula).reset_index()
#+end_src

#+begin_src jupyter-python :export none :results raw drawer
  zone_agg = robust_compare(sample, sample.ft.comp(),
                            zone, zc,
                            how='left',
                            suf1="samp", suf2="zone")[['Formula_samp', 'bg_eV']].fillna(0).groupby('Formula_samp', as_index=False).agg('median')
  zone_agg.bg_eV = zone_agg.bg_eV.apply(pd.to_numeric, errors='coerce')

  zone_rep = robust_compare(sample, sample.ft.comp(),
                            zone, zc,
                            how='left',
                            suf1="samp", suf2="zone")[['Formula_samp', 'bg_eV']].groupby('Formula_samp', as_index=False).count()
#+end_src

#+RESULTS:
:results:
# [goto error]
: [0;31m---------------------------------------------------------------------------[0m
: [0;31mNameError[0m                                 Traceback (most recent call last)
: [0;32m/tmp/ipykernel_13620/3082699280.py[0m in [0;36m<module>[0;34m[0m
: [1;32m      1[0m zone_agg = robust_compare(sample, sample.ft.comp(),
: [0;32m----> 2[0;31m                           [0mzone[0m[0;34m,[0m [0mzc[0m[0;34m,[0m[0;34m[0m[0;34m[0m[0m
: [0m[1;32m      3[0m                           [0mhow[0m[0;34m=[0m[0;34m'left'[0m[0;34m,[0m[0;34m[0m[0;34m[0m[0m
: [1;32m      4[0m                           suf1="samp", suf2="zone")[['Formula_samp', 'bg_eV']].fillna(0).groupby('Formula_samp', as_index=False).agg('median')
: [1;32m      5[0m [0mzone_agg[0m[0;34m.[0m[0mbg_eV[0m [0;34m=[0m [0mzone_agg[0m[0;34m.[0m[0mbg_eV[0m[0;34m.[0m[0mapply[0m[0;34m([0m[0mpd[0m[0;34m.[0m[0mto_numeric[0m[0;34m,[0m [0merrors[0m[0;34m=[0m[0;34m'coerce'[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
: 
: [0;31mNameError[0m: name 'zc' is not defined
:end:

#+begin_src jupyter-python :export none :results raw drawer
  zone_rep.set_index('Formula_samp').loc[sample.Formula, :].reset_index().bg_eV
  zone_rep.set_index('Formula_samp').reindex(sample.Formula).reset_index().bg_eV
#+end_src

[[cite:&jiang-2006-predic-lattic]]

[[cite:&briones-2021-accel-lattic]]

[[cite:&chen-2015-under-spotl]]
